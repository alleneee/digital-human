{"ast":null,"code":"var _jsxFileName = \"/Users/niko/digital-human/frontend/src/contexts/WebSocketContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\nimport { useConfig } from './ConfigContext';\nimport { useNotification } from './NotificationContext';\n\n// 创建上下文\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WebSocketContext = /*#__PURE__*/createContext();\n\n// WebSocket提供者组件\nexport const WebSocketProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    config\n  } = useConfig();\n  const {\n    success,\n    error\n  } = useNotification();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('offline');\n  const [statusMessage, setStatusMessage] = useState('等待连接...');\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadingMessage, setLoadingMessage] = useState('');\n\n  // 初始化WebSocket连接\n  const initWebSocket = useCallback(() => {\n    // 关闭已存在的连接\n    if (socket) {\n      socket.close();\n      setSocket(null);\n    }\n\n    // 更新状态为正在连接\n    updateStatus('connecting', '正在连接到服务器...');\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${protocol}//${window.location.host}/ws`;\n    let reconnectAttempts = 0;\n    const maxReconnectAttempts = 5;\n    const baseReconnectDelay = 1000; // 1秒\n\n    const connect = () => {\n      updateStatus('connecting', `连接中... ${reconnectAttempts > 0 ? `(尝试 ${reconnectAttempts}/${maxReconnectAttempts})` : ''}`);\n\n      // 创建WebSocket连接\n      const newSocket = new WebSocket(wsUrl);\n\n      // 连接打开\n      newSocket.onopen = () => {\n        console.log('WebSocket连接已建立');\n        setIsConnected(true);\n        updateStatus('online', '已连接');\n        reconnectAttempts = 0; // 重置重连计数\n\n        // 发送配置\n        newSocket.send(JSON.stringify({\n          type: 'config',\n          config: config\n        }));\n\n        // 显示成功通知\n        if (reconnectAttempts > 0) {\n          success('连接已恢复');\n        }\n      };\n\n      // 接收消息\n      newSocket.onmessage = event => {\n        // 处理二进制数据 (音频)\n        if (event.data instanceof Blob) {\n          handleAudioResponse(event.data);\n        }\n        // 处理JSON数据\n        else {\n          try {\n            const message = JSON.parse(event.data);\n            handleServerMessage(message);\n          } catch (e) {\n            console.error('解析服务器消息失败:', e);\n            error('服务器返回了无效数据');\n          }\n        }\n      };\n\n      // 连接关闭\n      newSocket.onclose = event => {\n        console.log(`WebSocket连接已关闭: ${event.code}`);\n        setIsConnected(false);\n        updateStatus('offline', '已断开连接');\n\n        // 重连逻辑\n        if (reconnectAttempts < maxReconnectAttempts) {\n          const delay = baseReconnectDelay * Math.pow(1.5, reconnectAttempts);\n          reconnectAttempts++;\n          console.log(`尝试重新连接... ${reconnectAttempts}/${maxReconnectAttempts} (${delay}ms后)`);\n          updateStatus('connecting', `将在${Math.round(delay / 1000)}秒后重新连接...`);\n          setTimeout(connect, delay);\n        } else {\n          updateStatus('offline', '连接失败，请刷新页面');\n          error('无法连接到服务器，请刷新页面重试');\n        }\n      };\n\n      // 连接错误\n      newSocket.onerror = connectionError => {\n        console.error('WebSocket错误:', connectionError);\n        updateStatus('offline', '连接错误');\n      };\n      setSocket(newSocket);\n    };\n\n    // 初始连接\n    connect();\n\n    // 清理函数\n    return () => {\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [config, error, success, updateStatus, handleServerMessage, handleAudioResponse, socket]);\n\n  // 更新连接状态\n  const updateStatus = useCallback((state, text) => {\n    setConnectionStatus(state);\n    setStatusMessage(text);\n  }, []);\n\n  // 处理服务器消息 - 会被Message组件使用，暂时为空\n  const handleServerMessage = useCallback(message => {\n    // 此函数将由具体的组件实现，这里只是提供接口\n    // 派发自定义事件，让相关组件可以捕获和处理\n    const event = new CustomEvent('server-message', {\n      detail: message\n    });\n    window.dispatchEvent(event);\n\n    // 处理加载状态\n    if (message.type === 'response' || message.type === 'error') {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // 处理音频响应 - 会被AudioPlayer组件使用，暂时为空\n  const handleAudioResponse = useCallback(audioBlob => {\n    // 此函数将由具体的组件实现，这里只是提供接口\n    // 派发自定义事件，让相关组件可以捕获和处理\n    const event = new CustomEvent('audio-response', {\n      detail: audioBlob\n    });\n    window.dispatchEvent(event);\n\n    // 处理加载状态\n    setIsLoading(false);\n  }, []);\n\n  // 发送消息\n  const sendMessage = useCallback((messageType, data) => {\n    if (!socket || !isConnected) {\n      error('未连接到服务器，请等待连接恢复');\n      return false;\n    }\n    const message = {\n      type: messageType,\n      ...data\n    };\n    socket.send(JSON.stringify(message));\n    return true;\n  }, [socket, isConnected, error]);\n\n  // 发送音频数据\n  const sendAudioData = useCallback(audioBlob => {\n    if (!socket || !isConnected) {\n      error('未连接到服务器，请等待连接恢复');\n      return false;\n    }\n    socket.send(audioBlob);\n    return true;\n  }, [socket, isConnected, error]);\n\n  // 设置加载状态\n  const setLoading = useCallback((loading, message = '处理中...') => {\n    setIsLoading(loading);\n    setLoadingMessage(message);\n  }, []);\n\n  // 初始化WebSocket\n  useEffect(() => {\n    initWebSocket();\n  }, [initWebSocket]);\n  return /*#__PURE__*/_jsxDEV(WebSocketContext.Provider, {\n    value: {\n      socket,\n      isConnected,\n      connectionStatus,\n      statusMessage,\n      isLoading,\n      loadingMessage,\n      setLoading,\n      sendMessage,\n      sendAudioData\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 191,\n    columnNumber: 5\n  }, this);\n};\n\n// 自定义Hook，用于在组件中访问WebSocket功能\n_s(WebSocketProvider, \"7fxcmgmJ2NAbqERdHV2RmJO99GY=\", false, function () {\n  return [useConfig, useNotification];\n});\n_c = WebSocketProvider;\nexport const useWebSocket = () => {\n  _s2();\n  const context = useContext(WebSocketContext);\n  if (!context) {\n    throw new Error('useWebSocket must be used within a WebSocketProvider');\n  }\n  return context;\n};\n_s2(useWebSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WebSocketProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","useConfig","useNotification","jsxDEV","_jsxDEV","WebSocketContext","WebSocketProvider","children","_s","config","success","error","socket","setSocket","isConnected","setIsConnected","connectionStatus","setConnectionStatus","statusMessage","setStatusMessage","isLoading","setIsLoading","loadingMessage","setLoadingMessage","initWebSocket","close","updateStatus","protocol","window","location","wsUrl","host","reconnectAttempts","maxReconnectAttempts","baseReconnectDelay","connect","newSocket","WebSocket","onopen","console","log","send","JSON","stringify","type","onmessage","event","data","Blob","handleAudioResponse","message","parse","handleServerMessage","e","onclose","code","delay","Math","pow","round","setTimeout","onerror","connectionError","state","text","CustomEvent","detail","dispatchEvent","audioBlob","sendMessage","messageType","sendAudioData","setLoading","loading","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWebSocket","_s2","context","Error","$RefreshReg$"],"sources":["/Users/niko/digital-human/frontend/src/contexts/WebSocketContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\nimport { useConfig } from './ConfigContext';\nimport { useNotification } from './NotificationContext';\n\n// 创建上下文\nconst WebSocketContext = createContext();\n\n// WebSocket提供者组件\nexport const WebSocketProvider = ({ children }) => {\n  const { config } = useConfig();\n  const { success, error } = useNotification();\n  \n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('offline');\n  const [statusMessage, setStatusMessage] = useState('等待连接...');\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadingMessage, setLoadingMessage] = useState('');\n\n  // 初始化WebSocket连接\n  const initWebSocket = useCallback(() => {\n    // 关闭已存在的连接\n    if (socket) {\n      socket.close();\n      setSocket(null);\n    }\n\n    // 更新状态为正在连接\n    updateStatus('connecting', '正在连接到服务器...');\n\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${protocol}//${window.location.host}/ws`;\n    \n    let reconnectAttempts = 0;\n    const maxReconnectAttempts = 5;\n    const baseReconnectDelay = 1000; // 1秒\n    \n    const connect = () => {\n      updateStatus('connecting', `连接中... ${reconnectAttempts > 0 ? `(尝试 ${reconnectAttempts}/${maxReconnectAttempts})` : ''}`);\n      \n      // 创建WebSocket连接\n      const newSocket = new WebSocket(wsUrl);\n      \n      // 连接打开\n      newSocket.onopen = () => {\n        console.log('WebSocket连接已建立');\n        setIsConnected(true);\n        updateStatus('online', '已连接');\n        reconnectAttempts = 0; // 重置重连计数\n        \n        // 发送配置\n        newSocket.send(JSON.stringify({\n          type: 'config',\n          config: config\n        }));\n        \n        // 显示成功通知\n        if (reconnectAttempts > 0) {\n          success('连接已恢复');\n        }\n      };\n      \n      // 接收消息\n      newSocket.onmessage = (event) => {\n        // 处理二进制数据 (音频)\n        if (event.data instanceof Blob) {\n          handleAudioResponse(event.data);\n        } \n        // 处理JSON数据\n        else {\n          try {\n            const message = JSON.parse(event.data);\n            handleServerMessage(message);\n          } catch (e) {\n            console.error('解析服务器消息失败:', e);\n            error('服务器返回了无效数据');\n          }\n        }\n      };\n      \n      // 连接关闭\n      newSocket.onclose = (event) => {\n        console.log(`WebSocket连接已关闭: ${event.code}`);\n        setIsConnected(false);\n        updateStatus('offline', '已断开连接');\n        \n        // 重连逻辑\n        if (reconnectAttempts < maxReconnectAttempts) {\n          const delay = baseReconnectDelay * Math.pow(1.5, reconnectAttempts);\n          reconnectAttempts++;\n          console.log(`尝试重新连接... ${reconnectAttempts}/${maxReconnectAttempts} (${delay}ms后)`);\n          \n          updateStatus('connecting', `将在${Math.round(delay/1000)}秒后重新连接...`);\n          \n          setTimeout(connect, delay);\n        } else {\n          updateStatus('offline', '连接失败，请刷新页面');\n          error('无法连接到服务器，请刷新页面重试');\n        }\n      };\n      \n      // 连接错误\n      newSocket.onerror = (connectionError) => {\n        console.error('WebSocket错误:', connectionError);\n        updateStatus('offline', '连接错误');\n      };\n\n      setSocket(newSocket);\n    };\n    \n    // 初始连接\n    connect();\n\n    // 清理函数\n    return () => {\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [config, error, success, updateStatus, handleServerMessage, handleAudioResponse, socket]);\n\n  // 更新连接状态\n  const updateStatus = useCallback((state, text) => {\n    setConnectionStatus(state);\n    setStatusMessage(text);\n  }, []);\n\n  // 处理服务器消息 - 会被Message组件使用，暂时为空\n  const handleServerMessage = useCallback((message) => {\n    // 此函数将由具体的组件实现，这里只是提供接口\n    // 派发自定义事件，让相关组件可以捕获和处理\n    const event = new CustomEvent('server-message', { detail: message });\n    window.dispatchEvent(event);\n\n    // 处理加载状态\n    if (message.type === 'response' || message.type === 'error') {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // 处理音频响应 - 会被AudioPlayer组件使用，暂时为空\n  const handleAudioResponse = useCallback((audioBlob) => {\n    // 此函数将由具体的组件实现，这里只是提供接口\n    // 派发自定义事件，让相关组件可以捕获和处理\n    const event = new CustomEvent('audio-response', { detail: audioBlob });\n    window.dispatchEvent(event);\n    \n    // 处理加载状态\n    setIsLoading(false);\n  }, []);\n\n  // 发送消息\n  const sendMessage = useCallback((messageType, data) => {\n    if (!socket || !isConnected) {\n      error('未连接到服务器，请等待连接恢复');\n      return false;\n    }\n\n    const message = {\n      type: messageType,\n      ...data\n    };\n\n    socket.send(JSON.stringify(message));\n    return true;\n  }, [socket, isConnected, error]);\n\n  // 发送音频数据\n  const sendAudioData = useCallback((audioBlob) => {\n    if (!socket || !isConnected) {\n      error('未连接到服务器，请等待连接恢复');\n      return false;\n    }\n\n    socket.send(audioBlob);\n    return true;\n  }, [socket, isConnected, error]);\n\n  // 设置加载状态\n  const setLoading = useCallback((loading, message = '处理中...') => {\n    setIsLoading(loading);\n    setLoadingMessage(message);\n  }, []);\n\n  // 初始化WebSocket\n  useEffect(() => {\n    initWebSocket();\n  }, [initWebSocket]);\n\n  return (\n    <WebSocketContext.Provider\n      value={{\n        socket,\n        isConnected,\n        connectionStatus,\n        statusMessage,\n        isLoading,\n        loadingMessage,\n        setLoading,\n        sendMessage,\n        sendAudioData\n      }}\n    >\n      {children}\n    </WebSocketContext.Provider>\n  );\n};\n\n// 自定义Hook，用于在组件中访问WebSocket功能\nexport const useWebSocket = () => {\n  const context = useContext(WebSocketContext);\n  if (!context) {\n    throw new Error('useWebSocket must be used within a WebSocketProvider');\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}