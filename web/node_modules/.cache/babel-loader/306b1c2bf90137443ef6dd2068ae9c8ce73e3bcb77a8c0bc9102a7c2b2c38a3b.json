{"ast":null,"code":"var _jsxFileName = \"/Users/niko/digital-human/frontend/src/contexts/WebSocketContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\nimport { useConfig } from './ConfigContext';\nimport { useNotification } from './NotificationContext';\n\n// 创建上下文\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WebSocketContext = /*#__PURE__*/createContext();\n\n// WebSocket提供者组件\nexport const WebSocketProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    config\n  } = useConfig();\n  const {\n    success,\n    error\n  } = useNotification();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('offline');\n  const [statusMessage, setStatusMessage] = useState('等待连接...');\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadingMessage, setLoadingMessage] = useState('');\n\n  // 初始化WebSocket连接\n  const initWebSocket = useCallback(() => {\n    // 修改WebSocket URL，确保连接到正确的后端地址\n    const wsUrl = 'ws://localhost:8000/ws';\n    let reconnectAttempts = 0;\n    const maxReconnectAttempts = 5;\n    const baseReconnectDelay = 1000; // 1秒\n\n    const connect = () => {\n      updateStatus('connecting', `连接中... ${reconnectAttempts > 0 ? `(尝试 ${reconnectAttempts}/${maxReconnectAttempts})` : ''}`);\n\n      // 创建WebSocket连接\n      const newSocket = new WebSocket(wsUrl);\n\n      // 连接打开\n      newSocket.onopen = () => {\n        console.log('WebSocket连接已建立');\n        setIsConnected(true);\n        updateStatus('online', '已连接');\n        reconnectAttempts = 0; // 重置重连计数\n\n        // 发送配置\n        newSocket.send(JSON.stringify({\n          type: 'config',\n          config: config\n        }));\n\n        // 显示成功通知\n        if (reconnectAttempts > 0) {\n          success('连接已恢复');\n        }\n      };\n\n      // 接收消息\n      newSocket.onmessage = event => {\n        // 处理二进制数据 (音频)\n        if (event.data instanceof Blob) {\n          handleAudioResponse(event.data);\n        }\n        // 处理JSON数据\n        else {\n          try {\n            const message = JSON.parse(event.data);\n            handleServerMessage(message);\n          } catch (e) {\n            console.error('解析服务器消息失败:', e);\n            error('服务器返回了无效数据');\n          }\n        }\n      };\n\n      // 连接关闭\n      newSocket.onclose = event => {\n        console.log(`WebSocket连接已关闭: ${event.code}`);\n        setIsConnected(false);\n        updateStatus('offline', '已断开连接');\n\n        // 重连逻辑\n        if (reconnectAttempts < maxReconnectAttempts) {\n          const delay = baseReconnectDelay * Math.pow(1.5, reconnectAttempts);\n          reconnectAttempts++;\n          console.log(`尝试重新连接... ${reconnectAttempts}/${maxReconnectAttempts} (${delay}ms后)`);\n          updateStatus('connecting', `将在${Math.round(delay / 1000)}秒后重新连接...`);\n          setTimeout(connect, delay);\n        } else {\n          updateStatus('offline', '连接失败，请刷新页面');\n          error('无法连接到服务器，请刷新页面重试');\n        }\n      };\n\n      // 连接错误\n      newSocket.onerror = connectionError => {\n        console.error('WebSocket错误:', connectionError);\n        updateStatus('offline', '连接错误');\n      };\n      setSocket(newSocket);\n    };\n\n    // 初始连接\n    connect();\n\n    // 清理函数\n    return () => {\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [config, error, success]);\n\n  // 更新连接状态\n  const updateStatus = useCallback((state, text) => {\n    setConnectionStatus(state);\n    setStatusMessage(text);\n  }, []);\n\n  // 处理服务器消息 - 会被Message组件使用，暂时为空\n  const handleServerMessage = useCallback(message => {\n    // 此函数将由具体的组件实现，这里只是提供接口\n    // 派发自定义事件，让相关组件可以捕获和处理\n    const event = new CustomEvent('server-message', {\n      detail: message\n    });\n    window.dispatchEvent(event);\n\n    // 处理加载状态\n    if (message.type === 'response' || message.type === 'error') {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // 处理音频响应 - 会被AudioPlayer组件使用，暂时为空\n  const handleAudioResponse = useCallback(audioBlob => {\n    // 此函数将由具体的组件实现，这里只是提供接口\n    // 派发自定义事件，让相关组件可以捕获和处理\n    const event = new CustomEvent('audio-response', {\n      detail: audioBlob\n    });\n    window.dispatchEvent(event);\n\n    // 处理加载状态\n    setIsLoading(false);\n  }, []);\n\n  // 发送消息\n  const sendMessage = useCallback((messageType, data) => {\n    if (!socket || !isConnected) {\n      error('未连接到服务器，请等待连接恢复');\n      return false;\n    }\n    const message = {\n      type: messageType,\n      ...data\n    };\n    socket.send(JSON.stringify(message));\n    return true;\n  }, [socket, isConnected, error]);\n\n  // 发送音频数据\n  const sendAudioData = useCallback(audioBlob => {\n    if (!socket || !isConnected) {\n      error('未连接到服务器，请等待连接恢复');\n      return false;\n    }\n    socket.send(audioBlob);\n    return true;\n  }, [socket, isConnected, error]);\n\n  // 设置加载状态\n  const setLoading = useCallback((loading, message = '处理中...') => {\n    setIsLoading(loading);\n    setLoadingMessage(message);\n  }, []);\n\n  // 初始化WebSocket\n  useEffect(() => {\n    initWebSocket();\n  }, [initWebSocket]);\n  return /*#__PURE__*/_jsxDEV(WebSocketContext.Provider, {\n    value: {\n      socket,\n      isConnected,\n      connectionStatus,\n      statusMessage,\n      isLoading,\n      loadingMessage,\n      setLoading,\n      sendMessage,\n      sendAudioData\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 182,\n    columnNumber: 5\n  }, this);\n};\n\n// 自定义Hook，用于在组件中访问WebSocket功能\n_s(WebSocketProvider, \"7fxcmgmJ2NAbqERdHV2RmJO99GY=\", false, function () {\n  return [useConfig, useNotification];\n});\n_c = WebSocketProvider;\nexport const useWebSocket = () => {\n  _s2();\n  const context = useContext(WebSocketContext);\n  if (!context) {\n    throw new Error('useWebSocket must be used within a WebSocketProvider');\n  }\n  return context;\n};\n_s2(useWebSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WebSocketProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","useConfig","useNotification","jsxDEV","_jsxDEV","WebSocketContext","WebSocketProvider","children","_s","config","success","error","socket","setSocket","isConnected","setIsConnected","connectionStatus","setConnectionStatus","statusMessage","setStatusMessage","isLoading","setIsLoading","loadingMessage","setLoadingMessage","initWebSocket","wsUrl","reconnectAttempts","maxReconnectAttempts","baseReconnectDelay","connect","updateStatus","newSocket","WebSocket","onopen","console","log","send","JSON","stringify","type","onmessage","event","data","Blob","handleAudioResponse","message","parse","handleServerMessage","e","onclose","code","delay","Math","pow","round","setTimeout","onerror","connectionError","close","state","text","CustomEvent","detail","window","dispatchEvent","audioBlob","sendMessage","messageType","sendAudioData","setLoading","loading","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWebSocket","_s2","context","Error","$RefreshReg$"],"sources":["/Users/niko/digital-human/frontend/src/contexts/WebSocketContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect, useCallback } from 'react';\nimport { useConfig } from './ConfigContext';\nimport { useNotification } from './NotificationContext';\n\n// 创建上下文\nconst WebSocketContext = createContext();\n\n// WebSocket提供者组件\nexport const WebSocketProvider = ({ children }) => {\n  const { config } = useConfig();\n  const { success, error } = useNotification();\n  \n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('offline');\n  const [statusMessage, setStatusMessage] = useState('等待连接...');\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadingMessage, setLoadingMessage] = useState('');\n\n  // 初始化WebSocket连接\n  const initWebSocket = useCallback(() => {\n    // 修改WebSocket URL，确保连接到正确的后端地址\n    const wsUrl = 'ws://localhost:8000/ws';\n    \n    let reconnectAttempts = 0;\n    const maxReconnectAttempts = 5;\n    const baseReconnectDelay = 1000; // 1秒\n    \n    const connect = () => {\n      updateStatus('connecting', `连接中... ${reconnectAttempts > 0 ? `(尝试 ${reconnectAttempts}/${maxReconnectAttempts})` : ''}`);\n      \n      // 创建WebSocket连接\n      const newSocket = new WebSocket(wsUrl);\n      \n      // 连接打开\n      newSocket.onopen = () => {\n        console.log('WebSocket连接已建立');\n        setIsConnected(true);\n        updateStatus('online', '已连接');\n        reconnectAttempts = 0; // 重置重连计数\n        \n        // 发送配置\n        newSocket.send(JSON.stringify({\n          type: 'config',\n          config: config\n        }));\n        \n        // 显示成功通知\n        if (reconnectAttempts > 0) {\n          success('连接已恢复');\n        }\n      };\n      \n      // 接收消息\n      newSocket.onmessage = (event) => {\n        // 处理二进制数据 (音频)\n        if (event.data instanceof Blob) {\n          handleAudioResponse(event.data);\n        } \n        // 处理JSON数据\n        else {\n          try {\n            const message = JSON.parse(event.data);\n            handleServerMessage(message);\n          } catch (e) {\n            console.error('解析服务器消息失败:', e);\n            error('服务器返回了无效数据');\n          }\n        }\n      };\n      \n      // 连接关闭\n      newSocket.onclose = (event) => {\n        console.log(`WebSocket连接已关闭: ${event.code}`);\n        setIsConnected(false);\n        updateStatus('offline', '已断开连接');\n        \n        // 重连逻辑\n        if (reconnectAttempts < maxReconnectAttempts) {\n          const delay = baseReconnectDelay * Math.pow(1.5, reconnectAttempts);\n          reconnectAttempts++;\n          console.log(`尝试重新连接... ${reconnectAttempts}/${maxReconnectAttempts} (${delay}ms后)`);\n          \n          updateStatus('connecting', `将在${Math.round(delay/1000)}秒后重新连接...`);\n          \n          setTimeout(connect, delay);\n        } else {\n          updateStatus('offline', '连接失败，请刷新页面');\n          error('无法连接到服务器，请刷新页面重试');\n        }\n      };\n      \n      // 连接错误\n      newSocket.onerror = (connectionError) => {\n        console.error('WebSocket错误:', connectionError);\n        updateStatus('offline', '连接错误');\n      };\n\n      setSocket(newSocket);\n    };\n    \n    // 初始连接\n    connect();\n\n    // 清理函数\n    return () => {\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [config, error, success]);\n\n  // 更新连接状态\n  const updateStatus = useCallback((state, text) => {\n    setConnectionStatus(state);\n    setStatusMessage(text);\n  }, []);\n\n  // 处理服务器消息 - 会被Message组件使用，暂时为空\n  const handleServerMessage = useCallback((message) => {\n    // 此函数将由具体的组件实现，这里只是提供接口\n    // 派发自定义事件，让相关组件可以捕获和处理\n    const event = new CustomEvent('server-message', { detail: message });\n    window.dispatchEvent(event);\n\n    // 处理加载状态\n    if (message.type === 'response' || message.type === 'error') {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // 处理音频响应 - 会被AudioPlayer组件使用，暂时为空\n  const handleAudioResponse = useCallback((audioBlob) => {\n    // 此函数将由具体的组件实现，这里只是提供接口\n    // 派发自定义事件，让相关组件可以捕获和处理\n    const event = new CustomEvent('audio-response', { detail: audioBlob });\n    window.dispatchEvent(event);\n    \n    // 处理加载状态\n    setIsLoading(false);\n  }, []);\n\n  // 发送消息\n  const sendMessage = useCallback((messageType, data) => {\n    if (!socket || !isConnected) {\n      error('未连接到服务器，请等待连接恢复');\n      return false;\n    }\n\n    const message = {\n      type: messageType,\n      ...data\n    };\n\n    socket.send(JSON.stringify(message));\n    return true;\n  }, [socket, isConnected, error]);\n\n  // 发送音频数据\n  const sendAudioData = useCallback((audioBlob) => {\n    if (!socket || !isConnected) {\n      error('未连接到服务器，请等待连接恢复');\n      return false;\n    }\n\n    socket.send(audioBlob);\n    return true;\n  }, [socket, isConnected, error]);\n\n  // 设置加载状态\n  const setLoading = useCallback((loading, message = '处理中...') => {\n    setIsLoading(loading);\n    setLoadingMessage(message);\n  }, []);\n\n  // 初始化WebSocket\n  useEffect(() => {\n    initWebSocket();\n  }, [initWebSocket]);\n\n  return (\n    <WebSocketContext.Provider\n      value={{\n        socket,\n        isConnected,\n        connectionStatus,\n        statusMessage,\n        isLoading,\n        loadingMessage,\n        setLoading,\n        sendMessage,\n        sendAudioData\n      }}\n    >\n      {children}\n    </WebSocketContext.Provider>\n  );\n};\n\n// 自定义Hook，用于在组件中访问WebSocket功能\nexport const useWebSocket = () => {\n  const context = useContext(WebSocketContext);\n  if (!context) {\n    throw new Error('useWebSocket must be used within a WebSocketProvider');\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}