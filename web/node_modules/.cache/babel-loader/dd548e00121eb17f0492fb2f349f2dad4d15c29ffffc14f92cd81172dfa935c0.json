{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { isTextSource, isUrlSource } from \"../lib/helpers\";\nimport { DeepgramError, isDeepgramError } from \"../lib/errors\";\nimport { AbstractRestClient } from \"./AbstractRestClient\";\n/**\n * The `ReadRestClient` class extends the `AbstractRestClient` class and provides methods for analyzing audio sources synchronously and asynchronously.\n *\n * The `analyzeUrl` method analyzes a URL-based audio source synchronously, returning a promise that resolves to the analysis response or an error.\n *\n * The `analyzeText` method analyzes a text-based audio source synchronously, returning a promise that resolves to the analysis response or an error.\n *\n * The `analyzeUrlCallback` method analyzes a URL-based audio source asynchronously, returning a promise that resolves to the analysis response or an error.\n *\n * The `analyzeTextCallback` method analyzes a text-based audio source asynchronously, returning a promise that resolves to the analysis response or an error.\n */\nexport class ReadRestClient extends AbstractRestClient {\n  constructor() {\n    super(...arguments);\n    this.namespace = \"read\";\n  }\n  /**\n   * Analyzes a URL-based audio source synchronously.\n   *\n   * @param source - The URL-based audio source to analyze.\n   * @param options - Optional analysis options.\n   * @param endpoint - The API endpoint to use for the analysis. Defaults to \":version/read\".\n   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.\n   */\n  analyzeUrl(source, options, endpoint = \":version/read\") {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        let body;\n        if (isUrlSource(source)) {\n          body = JSON.stringify(source);\n        } else {\n          throw new DeepgramError(\"Unknown source type\");\n        }\n        if (options !== undefined && \"callback\" in options) {\n          throw new DeepgramError(\"Callback cannot be provided as an option to a synchronous transcription. Use `analyzeUrlCallback` or `analyzeTextCallback` instead.\");\n        }\n        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign({}, options));\n        const result = yield this.post(requestUrl, body).then(result => result.json());\n        return {\n          result,\n          error: null\n        };\n      } catch (error) {\n        if (isDeepgramError(error)) {\n          return {\n            result: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Analyzes a text-based audio source synchronously.\n   *\n   * @param source - The text-based audio source to analyze.\n   * @param options - Optional analysis options.\n   * @param endpoint - The API endpoint to use for the analysis. Defaults to \":version/read\".\n   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.\n   */\n  analyzeText(source, options, endpoint = \":version/read\") {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        let body;\n        if (isTextSource(source)) {\n          body = JSON.stringify(source);\n        } else {\n          throw new DeepgramError(\"Unknown source type\");\n        }\n        if (options !== undefined && \"callback\" in options) {\n          throw new DeepgramError(\"Callback cannot be provided as an option to a synchronous requests. Use `analyzeUrlCallback` or `analyzeTextCallback` instead.\");\n        }\n        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign({}, options));\n        const result = yield this.post(requestUrl, body).then(result => result.json());\n        return {\n          result,\n          error: null\n        };\n      } catch (error) {\n        if (isDeepgramError(error)) {\n          return {\n            result: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Analyzes a URL-based audio source asynchronously.\n   *\n   * @param source - The URL-based audio source to analyze.\n   * @param callback - The URL to call back with the analysis results.\n   * @param options - Optional analysis options.\n   * @param endpoint - The API endpoint to use for the analysis. Defaults to \":version/read\".\n   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.\n   */\n  analyzeUrlCallback(source, callback, options, endpoint = \":version/read\") {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        let body;\n        if (isUrlSource(source)) {\n          body = JSON.stringify(source);\n        } else {\n          throw new DeepgramError(\"Unknown source type\");\n        }\n        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign(Object.assign({}, options), {\n          callback: callback.toString()\n        }));\n        const result = yield this.post(requestUrl, body).then(result => result.json());\n        return {\n          result,\n          error: null\n        };\n      } catch (error) {\n        if (isDeepgramError(error)) {\n          return {\n            result: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Analyzes a text-based audio source asynchronously.\n   *\n   * @param source - The text-based audio source to analyze.\n   * @param callback - The URL to call back with the analysis results.\n   * @param options - Optional analysis options.\n   * @param endpoint - The API endpoint to use for the analysis. Defaults to \":version/read\".\n   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.\n   */\n  analyzeTextCallback(source, callback, options, endpoint = \":version/read\") {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        let body;\n        if (isTextSource(source)) {\n          body = JSON.stringify(source);\n        } else {\n          throw new DeepgramError(\"Unknown source type\");\n        }\n        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign(Object.assign({}, options), {\n          callback: callback.toString()\n        }));\n        const result = yield this.post(requestUrl, body, {\n          headers: {\n            \"Content-Type\": \"deepgram/audio+video\"\n          }\n        }).then(result => result.json());\n        return {\n          result,\n          error: null\n        };\n      } catch (error) {\n        if (isDeepgramError(error)) {\n          return {\n            result: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n}\nexport { ReadRestClient as ReadClient };","map":{"version":3,"names":["isTextSource","isUrlSource","DeepgramError","isDeepgramError","AbstractRestClient","ReadRestClient","constructor","namespace","analyzeUrl","source","options","endpoint","body","JSON","stringify","undefined","requestUrl","getRequestUrl","Object","assign","result","post","then","json","error","analyzeText","analyzeUrlCallback","callback","toString","analyzeTextCallback","headers","ReadClient"],"sources":["/Users/niko/node_modules/.pnpm/@deepgram+sdk@3.11.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@deepgram/sdk/src/packages/ReadRestClient.ts"],"sourcesContent":["import { CallbackUrl, isTextSource, isUrlSource } from \"../lib/helpers\";\nimport { DeepgramError, isDeepgramError } from \"../lib/errors\";\nimport type {\n  AnalyzeSchema,\n  AsyncAnalyzeResponse,\n  DeepgramResponse,\n  SyncAnalyzeResponse,\n  TextSource,\n  UrlSource,\n} from \"../lib/types\";\nimport { AbstractRestClient } from \"./AbstractRestClient\";\n\n/**\n * The `ReadRestClient` class extends the `AbstractRestClient` class and provides methods for analyzing audio sources synchronously and asynchronously.\n *\n * The `analyzeUrl` method analyzes a URL-based audio source synchronously, returning a promise that resolves to the analysis response or an error.\n *\n * The `analyzeText` method analyzes a text-based audio source synchronously, returning a promise that resolves to the analysis response or an error.\n *\n * The `analyzeUrlCallback` method analyzes a URL-based audio source asynchronously, returning a promise that resolves to the analysis response or an error.\n *\n * The `analyzeTextCallback` method analyzes a text-based audio source asynchronously, returning a promise that resolves to the analysis response or an error.\n */\nexport class ReadRestClient extends AbstractRestClient {\n  public namespace: string = \"read\";\n\n  /**\n   * Analyzes a URL-based audio source synchronously.\n   *\n   * @param source - The URL-based audio source to analyze.\n   * @param options - Optional analysis options.\n   * @param endpoint - The API endpoint to use for the analysis. Defaults to \":version/read\".\n   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.\n   */\n  async analyzeUrl(\n    source: UrlSource,\n    options?: AnalyzeSchema,\n    endpoint = \":version/read\"\n  ): Promise<DeepgramResponse<SyncAnalyzeResponse>> {\n    try {\n      let body;\n\n      if (isUrlSource(source)) {\n        body = JSON.stringify(source);\n      } else {\n        throw new DeepgramError(\"Unknown source type\");\n      }\n\n      if (options !== undefined && \"callback\" in options) {\n        throw new DeepgramError(\n          \"Callback cannot be provided as an option to a synchronous transcription. Use `analyzeUrlCallback` or `analyzeTextCallback` instead.\"\n        );\n      }\n\n      const requestUrl = this.getRequestUrl(endpoint, {}, { ...{}, ...options });\n      const result: SyncAnalyzeResponse = await this.post(requestUrl, body).then((result) =>\n        result.json()\n      );\n\n      return { result, error: null };\n    } catch (error) {\n      if (isDeepgramError(error)) {\n        return { result: null, error };\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Analyzes a text-based audio source synchronously.\n   *\n   * @param source - The text-based audio source to analyze.\n   * @param options - Optional analysis options.\n   * @param endpoint - The API endpoint to use for the analysis. Defaults to \":version/read\".\n   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.\n   */\n  async analyzeText(\n    source: TextSource,\n    options?: AnalyzeSchema,\n    endpoint = \":version/read\"\n  ): Promise<DeepgramResponse<SyncAnalyzeResponse>> {\n    try {\n      let body;\n\n      if (isTextSource(source)) {\n        body = JSON.stringify(source);\n      } else {\n        throw new DeepgramError(\"Unknown source type\");\n      }\n\n      if (options !== undefined && \"callback\" in options) {\n        throw new DeepgramError(\n          \"Callback cannot be provided as an option to a synchronous requests. Use `analyzeUrlCallback` or `analyzeTextCallback` instead.\"\n        );\n      }\n\n      const requestUrl = this.getRequestUrl(endpoint, {}, { ...{}, ...options });\n      const result: SyncAnalyzeResponse = await this.post(requestUrl, body).then((result) =>\n        result.json()\n      );\n\n      return { result, error: null };\n    } catch (error) {\n      if (isDeepgramError(error)) {\n        return { result: null, error };\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Analyzes a URL-based audio source asynchronously.\n   *\n   * @param source - The URL-based audio source to analyze.\n   * @param callback - The URL to call back with the analysis results.\n   * @param options - Optional analysis options.\n   * @param endpoint - The API endpoint to use for the analysis. Defaults to \":version/read\".\n   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.\n   */\n  async analyzeUrlCallback(\n    source: UrlSource,\n    callback: CallbackUrl,\n    options?: AnalyzeSchema,\n    endpoint = \":version/read\"\n  ): Promise<DeepgramResponse<AsyncAnalyzeResponse>> {\n    try {\n      let body;\n\n      if (isUrlSource(source)) {\n        body = JSON.stringify(source);\n      } else {\n        throw new DeepgramError(\"Unknown source type\");\n      }\n\n      const requestUrl = this.getRequestUrl(\n        endpoint,\n        {},\n        { ...options, callback: callback.toString() }\n      );\n      const result: AsyncAnalyzeResponse = await this.post(requestUrl, body).then((result) =>\n        result.json()\n      );\n\n      return { result, error: null };\n    } catch (error) {\n      if (isDeepgramError(error)) {\n        return { result: null, error };\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Analyzes a text-based audio source asynchronously.\n   *\n   * @param source - The text-based audio source to analyze.\n   * @param callback - The URL to call back with the analysis results.\n   * @param options - Optional analysis options.\n   * @param endpoint - The API endpoint to use for the analysis. Defaults to \":version/read\".\n   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.\n   */\n  async analyzeTextCallback(\n    source: TextSource,\n    callback: CallbackUrl,\n    options?: AnalyzeSchema,\n    endpoint = \":version/read\"\n  ): Promise<DeepgramResponse<AsyncAnalyzeResponse>> {\n    try {\n      let body;\n\n      if (isTextSource(source)) {\n        body = JSON.stringify(source);\n      } else {\n        throw new DeepgramError(\"Unknown source type\");\n      }\n\n      const requestUrl = this.getRequestUrl(\n        endpoint,\n        {},\n        { ...options, callback: callback.toString() }\n      );\n      const result: AsyncAnalyzeResponse = await this.post(requestUrl, body, {\n        headers: { \"Content-Type\": \"deepgram/audio+video\" },\n      }).then((result) => result.json());\n\n      return { result, error: null };\n    } catch (error) {\n      if (isDeepgramError(error)) {\n        return { result: null, error };\n      }\n\n      throw error;\n    }\n  }\n}\n\nexport { ReadRestClient as ReadClient };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}