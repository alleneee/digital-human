{"ast":null,"code":"var _jsxFileName = \"/Users/niko/digital-human/frontend/src/contexts/WebSocketContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect, useCallback, useRef } from 'react';\nimport { useConfig } from './ConfigContext';\nimport { useNotification } from './NotificationContext';\n\n// 创建上下文\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WebSocketContext = /*#__PURE__*/createContext();\n\n// WebSocket提供者组件\nexport const WebSocketProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    config\n  } = useConfig();\n  const {\n    success,\n    error\n  } = useNotification();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('offline');\n  const [statusMessage, setStatusMessage] = useState('等待连接...');\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadingMessage, setLoadingMessage] = useState('');\n  const [lastMessage, setLastMessage] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [webrtcSupported, setWebrtcSupported] = useState(null);\n  const [pendingMessages, setPendingMessages] = useState([]);\n  const [connectionStats, setConnectionStats] = useState({\n    pingTime: null,\n    avgLatency: 0,\n    lastPingAt: null,\n    reconnectCount: 0\n  });\n\n  // 使用refs存储一些不需要触发重渲染的值\n  const socketRef = useRef(null);\n  const pingIntervalRef = useRef(null);\n  const lastPingSentRef = useRef(null);\n\n  // 初始化WebSocket连接\n  const initWebSocket = useCallback(() => {\n    // 修改WebSocket URL，确保连接到正确的后端地址\n    const wsUrl = 'ws://localhost:8000/ws';\n    let reconnectAttempts = 0;\n    const maxReconnectAttempts = 20; // 增加最大重连次数\n    const baseReconnectDelay = 1000; // 1秒\n    const reconnectBackoffFactor = 1.5; // 指数退避因子\n\n    const connect = () => {\n      updateStatus('connecting', `连接中... ${reconnectAttempts > 0 ? `(尝试 ${reconnectAttempts}/${maxReconnectAttempts})` : ''}`);\n      console.log(`尝试连接到WebSocket: ${wsUrl}`);\n\n      // 创建WebSocket连接\n      const newSocket = new WebSocket(wsUrl);\n      socketRef.current = newSocket;\n\n      // 连接打开\n      newSocket.onopen = () => {\n        console.log('WebSocket连接已建立');\n        setIsConnected(true);\n        updateStatus('online', '已连接');\n        reconnectAttempts = 0; // 重置重连计数\n\n        // 更新连接统计\n        setConnectionStats(prev => ({\n          ...prev,\n          reconnectCount: prev.reconnectCount + 1,\n          lastConnectedAt: Date.now()\n        }));\n\n        // 发送配置\n        newSocket.send(JSON.stringify({\n          type: 'config',\n          config: config\n        }));\n\n        // 开始ping测试\n        clearInterval(pingIntervalRef.current);\n        pingIntervalRef.current = setInterval(() => {\n          if (newSocket.readyState === WebSocket.OPEN) {\n            const pingTime = Date.now();\n            lastPingSentRef.current = pingTime;\n            try {\n              newSocket.send(JSON.stringify({\n                type: 'ping',\n                timestamp: pingTime\n              }));\n            } catch (err) {\n              console.error('发送ping失败:', err);\n            }\n          }\n        }, 10000); // 10秒一次\n\n        // 处理之前缓存的消息\n        if (pendingMessages.length > 0) {\n          console.log(`发送${pendingMessages.length}条缓存消息`);\n          pendingMessages.forEach(msg => {\n            try {\n              newSocket.send(JSON.stringify(msg));\n            } catch (err) {\n              console.error('发送缓存消息失败:', err);\n            }\n          });\n\n          // 清空缓存\n          setPendingMessages([]);\n          success(`已恢复连接并发送${pendingMessages.length}条缓存消息`);\n        } else {\n          // 显示成功通知\n          if (reconnectAttempts > 0) {\n            success('连接已恢复');\n          }\n        }\n      };\n\n      // 连接关闭\n      newSocket.onclose = event => {\n        console.log('WebSocket连接已关闭:', event);\n        setIsConnected(false);\n\n        // 清除ping间隔\n        clearInterval(pingIntervalRef.current);\n        if (reconnectAttempts < maxReconnectAttempts) {\n          // 改进的指数退避重连\n          const delay = Math.min(baseReconnectDelay * Math.pow(reconnectBackoffFactor, reconnectAttempts), 60000);\n          reconnectAttempts++;\n          updateStatus('reconnecting', `连接已断开，${Math.round(delay / 1000)}秒后重连... (${reconnectAttempts}/${maxReconnectAttempts})`);\n\n          // 显示重连通知\n          if (reconnectAttempts === 1) {\n            error('连接已断开，正在尝试重连...');\n          } else if (reconnectAttempts % 5 === 0) {\n            // 每5次重试显示一次通知\n            error(`连接尝试 ${reconnectAttempts}/${maxReconnectAttempts}, ${Math.round(delay / 1000)}秒后重试`);\n          }\n          setTimeout(connect, delay);\n        } else {\n          updateStatus('offline', '连接失败，请检查网络并刷新页面');\n          error('连接失败，请检查网络并刷新页面。您可以尝试重新加载页面恢复连接。');\n\n          // 提供自动重新加载选项\n          if (confirm('连接失败，是否要重新加载页面尝试恢复连接？')) {\n            window.location.reload();\n          }\n        }\n      };\n\n      // 连接错误\n      newSocket.onerror = err => {\n        console.error('WebSocket连接错误:', err);\n        error('连接发生错误，正在尝试重连...');\n      };\n\n      // 收到消息\n      newSocket.onmessage = event => {\n        try {\n          // 检查是否为二进制数据（音频）\n          if (event.data instanceof Blob) {\n            console.log('收到二进制数据:', event.data.size, event.data.type);\n            handleBinaryMessage(event.data);\n            return;\n          }\n\n          // 尝试解析JSON消息\n          const data = JSON.parse(event.data);\n          console.log('收到JSON消息:', data);\n\n          // 处理ping响应\n          if (data.type === 'pong' && lastPingSentRef.current) {\n            const latency = Date.now() - data.original_timestamp;\n            console.log(`网络延迟: ${latency}ms`);\n            setConnectionStats(prev => {\n              // 计算移动平均延迟\n              const newAvgLatency = prev.avgLatency ? prev.avgLatency * 0.8 + latency * 0.2 : latency;\n              return {\n                ...prev,\n                pingTime: latency,\n                avgLatency: newAvgLatency,\n                lastPingAt: Date.now()\n              };\n            });\n          }\n\n          // 更新最近消息状态\n          setLastMessage(data);\n\n          // 根据消息类型处理\n          switch (data.type) {\n            case 'thinking':\n              setLoading(true, data.message || '思考中...');\n              break;\n            case 'bot_reply':\n              // 添加消息到历史\n              addMessage({\n                role: 'assistant',\n                content: data.text || data.message,\n                timestamp: new Date().toISOString()\n              });\n              setLoading(false);\n              break;\n            case 'transcription':\n              // 处理语音转写结果\n              if (data.final) {\n                addMessage({\n                  role: 'user',\n                  content: data.text,\n                  timestamp: new Date().toISOString()\n                });\n              }\n              break;\n            case 'generating_video':\n              setLoading(true, data.message || '生成视频中...');\n              break;\n            case 'video_ready':\n              setLoading(false);\n              if (data.success && data.video_url) {\n                console.log('视频已就绪:', data.video_url);\n\n                // 添加视频消息\n                addMessage({\n                  role: 'assistant',\n                  content: data.message || '视频已准备就绪',\n                  video_url: data.video_url,\n                  timestamp: new Date().toISOString()\n                });\n              }\n              break;\n            case 'webrtc_support':\n              // 更新WebRTC支持状态\n              setWebrtcSupported(data.supported);\n              console.log('服务器WebRTC支持状态:', data.supported);\n              if (data.supported) {\n                success('语音转写功能已就绪');\n              } else {\n                console.warn('服务器不支持WebRTC或Deepgram集成，将使用备用方法');\n              }\n              break;\n            case 'error':\n              setLoading(false);\n              error(data.message || '发生错误');\n\n              // 添加错误消息\n              addMessage({\n                role: 'system',\n                content: data.message || '发生错误',\n                error: true,\n                timestamp: new Date().toISOString()\n              });\n              break;\n            default:\n              break;\n          }\n        } catch (err) {\n          console.error('处理WebSocket消息错误:', err);\n        }\n      };\n      setSocket(newSocket);\n    };\n    connect();\n\n    // 组件卸载时清理WebSocket连接和定时器\n    return () => {\n      clearInterval(pingIntervalRef.current);\n      if (socketRef.current) {\n        socketRef.current.close();\n      }\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [config, success, error]);\n\n  // 组件挂载时初始化WebSocket\n  useEffect(() => {\n    initWebSocket();\n\n    // 清理函数\n    return () => {\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [initWebSocket]);\n\n  // 更新状态\n  const updateStatus = (status, message) => {\n    setConnectionStatus(status);\n    setStatusMessage(message);\n  };\n\n  // 设置加载状态\n  const setLoading = (isLoading, message = '') => {\n    setIsLoading(isLoading);\n    setLoadingMessage(message);\n  };\n\n  // 添加消息到历史记录\n  const addMessage = message => {\n    setMessages(prevMessages => [...prevMessages, message]);\n\n    // 触发消息事件，方便其他组件监听\n    const event = new CustomEvent('new-message', {\n      detail: message\n    });\n    window.dispatchEvent(event);\n  };\n\n  // 发送文本消息\n  const sendMessage = useCallback(message => {\n    // 如果传入的是字符串，转换为标准消息格式\n    const messageToSend = typeof message === 'string' ? {\n      type: 'text_input',\n      text: message\n    } : message;\n\n    // 添加网络状态和时间戳\n    const enhancedMessage = {\n      ...messageToSend,\n      client_timestamp: Date.now(),\n      client_connection_stats: connectionStats\n    };\n\n    // 检查websocket连接状态\n    if (!socket || socket.readyState !== WebSocket.OPEN) {\n      console.warn('WebSocket连接未建立，消息将被缓存');\n\n      // 缓存消息，等待重连后发送\n      if (messageToSend.type !== 'ping') {\n        // 不缓存ping消息\n        setPendingMessages(prev => [...prev, enhancedMessage]);\n\n        // 只有在特定消息类型时才显示通知\n        if (['text_input', 'transcription', 'transcription_complete'].includes(messageToSend.type)) {\n          error('网络连接中断，消息将在重连后发送');\n        }\n      }\n      return false;\n    }\n    try {\n      // 记录用户消息（对于文本输入类型）\n      if (messageToSend.type === 'text_input' && messageToSend.text) {\n        addMessage({\n          role: 'user',\n          content: messageToSend.text,\n          timestamp: new Date().toISOString(),\n          pending: pendingMessages.length > 0 // 标记是否有待发送消息\n        });\n\n        // 设置处理状态\n        setIsProcessing(true);\n      }\n      console.log('发送WebSocket消息:', enhancedMessage);\n      socket.send(JSON.stringify(enhancedMessage));\n      return true;\n    } catch (err) {\n      console.error(`发送消息失败: ${err.message}`);\n\n      // 发送失败，缓存消息（除了ping）\n      if (messageToSend.type !== 'ping') {\n        setPendingMessages(prev => [...prev, enhancedMessage]);\n        error(`发送消息失败: ${err.message}，将在连接恢复后重试`);\n      }\n      setIsProcessing(false);\n      return false;\n    }\n  }, [socket, error]);\n\n  // 处理二进制消息(用于音频播放)\n  const handleBinaryMessage = binaryData => {\n    // 处理接收到的二进制数据(通常是音频)\n    try {\n      // 创建音频URL\n      const audioUrl = URL.createObjectURL(binaryData);\n\n      // 创建音频元素并播放\n      const audio = new Audio(audioUrl);\n\n      // 播放完成后释放URL\n      audio.onended = () => {\n        URL.revokeObjectURL(audioUrl);\n      };\n      audio.onerror = err => {\n        console.error('音频播放错误:', err);\n        URL.revokeObjectURL(audioUrl);\n      };\n\n      // 播放音频\n      audio.play().catch(err => {\n        console.error('无法自动播放音频:', err);\n        error('请点击页面以启用音频播放');\n      });\n    } catch (err) {\n      console.error('处理二进制数据错误:', err);\n    }\n  };\n\n  // 提供上下文值\n  const contextValue = {\n    socket,\n    isConnected,\n    connectionStatus,\n    statusMessage,\n    isLoading,\n    loadingMessage,\n    lastMessage,\n    messages,\n    isProcessing,\n    webrtcSupported,\n    connectionStats,\n    pendingMessages,\n    sendMessage,\n    addMessage,\n    setLoading,\n    clearMessages: () => setMessages([]),\n    clearPendingMessages: () => setPendingMessages([]),\n    hasPendingMessages: pendingMessages.length > 0\n  };\n  return /*#__PURE__*/_jsxDEV(WebSocketContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 434,\n    columnNumber: 5\n  }, this);\n};\n\n// 自定义Hook，用于在组件中访问WebSocket功能\n_s(WebSocketProvider, \"luLNRcYrEvbOFqAL8pAvui594sU=\", false, function () {\n  return [useConfig, useNotification];\n});\n_c = WebSocketProvider;\nexport const useWebSocket = () => {\n  _s2();\n  const context = useContext(WebSocketContext);\n  if (!context) {\n    throw new Error('useWebSocket 必须在 WebSocketProvider 内部使用');\n  }\n  return context;\n};\n_s2(useWebSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WebSocketProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useCallback","useRef","useConfig","useNotification","jsxDEV","_jsxDEV","WebSocketContext","WebSocketProvider","children","_s","config","success","error","socket","setSocket","isConnected","setIsConnected","connectionStatus","setConnectionStatus","statusMessage","setStatusMessage","isLoading","setIsLoading","loadingMessage","setLoadingMessage","lastMessage","setLastMessage","messages","setMessages","isProcessing","setIsProcessing","webrtcSupported","setWebrtcSupported","pendingMessages","setPendingMessages","connectionStats","setConnectionStats","pingTime","avgLatency","lastPingAt","reconnectCount","socketRef","pingIntervalRef","lastPingSentRef","initWebSocket","wsUrl","reconnectAttempts","maxReconnectAttempts","baseReconnectDelay","reconnectBackoffFactor","connect","updateStatus","console","log","newSocket","WebSocket","current","onopen","prev","lastConnectedAt","Date","now","send","JSON","stringify","type","clearInterval","setInterval","readyState","OPEN","timestamp","err","length","forEach","msg","onclose","event","delay","Math","min","pow","round","setTimeout","confirm","window","location","reload","onerror","onmessage","data","Blob","size","handleBinaryMessage","parse","latency","original_timestamp","newAvgLatency","setLoading","message","addMessage","role","content","text","toISOString","final","video_url","supported","warn","close","status","prevMessages","CustomEvent","detail","dispatchEvent","sendMessage","messageToSend","enhancedMessage","client_timestamp","client_connection_stats","includes","pending","binaryData","audioUrl","URL","createObjectURL","audio","Audio","onended","revokeObjectURL","play","catch","contextValue","clearMessages","clearPendingMessages","hasPendingMessages","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWebSocket","_s2","context","Error","$RefreshReg$"],"sources":["/Users/niko/digital-human/frontend/src/contexts/WebSocketContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect, useCallback, useRef } from 'react';\nimport { useConfig } from './ConfigContext';\nimport { useNotification } from './NotificationContext';\n\n// 创建上下文\nconst WebSocketContext = createContext();\n\n// WebSocket提供者组件\nexport const WebSocketProvider = ({ children }) => {\n  const { config } = useConfig();\n  const { success, error } = useNotification();\n  \n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('offline');\n  const [statusMessage, setStatusMessage] = useState('等待连接...');\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadingMessage, setLoadingMessage] = useState('');\n  const [lastMessage, setLastMessage] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [webrtcSupported, setWebrtcSupported] = useState(null);\n  const [pendingMessages, setPendingMessages] = useState([]);\n  const [connectionStats, setConnectionStats] = useState({\n    pingTime: null,\n    avgLatency: 0,\n    lastPingAt: null,\n    reconnectCount: 0\n  });\n  \n  // 使用refs存储一些不需要触发重渲染的值\n  const socketRef = useRef(null);\n  const pingIntervalRef = useRef(null);\n  const lastPingSentRef = useRef(null);\n\n  // 初始化WebSocket连接\n  const initWebSocket = useCallback(() => {\n    // 修改WebSocket URL，确保连接到正确的后端地址\n    const wsUrl = 'ws://localhost:8000/ws';\n    \n    let reconnectAttempts = 0;\n    const maxReconnectAttempts = 20; // 增加最大重连次数\n    const baseReconnectDelay = 1000; // 1秒\n    const reconnectBackoffFactor = 1.5; // 指数退避因子\n    \n    const connect = () => {\n      updateStatus('connecting', `连接中... ${reconnectAttempts > 0 ? `(尝试 ${reconnectAttempts}/${maxReconnectAttempts})` : ''}`);\n      \n      console.log(`尝试连接到WebSocket: ${wsUrl}`);\n      \n      // 创建WebSocket连接\n      const newSocket = new WebSocket(wsUrl);\n      socketRef.current = newSocket;\n      \n      // 连接打开\n      newSocket.onopen = () => {\n        console.log('WebSocket连接已建立');\n        setIsConnected(true);\n        updateStatus('online', '已连接');\n        reconnectAttempts = 0; // 重置重连计数\n        \n        // 更新连接统计\n        setConnectionStats(prev => ({\n          ...prev,\n          reconnectCount: prev.reconnectCount + 1,\n          lastConnectedAt: Date.now()\n        }));\n        \n        // 发送配置\n        newSocket.send(JSON.stringify({\n          type: 'config',\n          config: config\n        }));\n        \n        // 开始ping测试\n        clearInterval(pingIntervalRef.current);\n        pingIntervalRef.current = setInterval(() => {\n          if (newSocket.readyState === WebSocket.OPEN) {\n            const pingTime = Date.now();\n            lastPingSentRef.current = pingTime;\n            try {\n              newSocket.send(JSON.stringify({\n                type: 'ping',\n                timestamp: pingTime\n              }));\n            } catch (err) {\n              console.error('发送ping失败:', err);\n            }\n          }\n        }, 10000); // 10秒一次\n        \n        // 处理之前缓存的消息\n        if (pendingMessages.length > 0) {\n          console.log(`发送${pendingMessages.length}条缓存消息`);\n          pendingMessages.forEach(msg => {\n            try {\n              newSocket.send(JSON.stringify(msg));\n            } catch (err) {\n              console.error('发送缓存消息失败:', err);\n            }\n          });\n          \n          // 清空缓存\n          setPendingMessages([]);\n          success(`已恢复连接并发送${pendingMessages.length}条缓存消息`);\n        } else {\n          // 显示成功通知\n          if (reconnectAttempts > 0) {\n            success('连接已恢复');\n          }\n        }\n      };\n      \n      // 连接关闭\n      newSocket.onclose = (event) => {\n        console.log('WebSocket连接已关闭:', event);\n        setIsConnected(false);\n        \n        // 清除ping间隔\n        clearInterval(pingIntervalRef.current);\n        \n        if (reconnectAttempts < maxReconnectAttempts) {\n          // 改进的指数退避重连\n          const delay = Math.min(baseReconnectDelay * Math.pow(reconnectBackoffFactor, reconnectAttempts), 60000);\n          reconnectAttempts++;\n          \n          updateStatus('reconnecting', `连接已断开，${Math.round(delay / 1000)}秒后重连... (${reconnectAttempts}/${maxReconnectAttempts})`);\n          \n          // 显示重连通知\n          if (reconnectAttempts === 1) {\n            error('连接已断开，正在尝试重连...');\n          } else if (reconnectAttempts % 5 === 0) {\n            // 每5次重试显示一次通知\n            error(`连接尝试 ${reconnectAttempts}/${maxReconnectAttempts}, ${Math.round(delay / 1000)}秒后重试`);\n          }\n          \n          setTimeout(connect, delay);\n        } else {\n          updateStatus('offline', '连接失败，请检查网络并刷新页面');\n          error('连接失败，请检查网络并刷新页面。您可以尝试重新加载页面恢复连接。');\n          \n          // 提供自动重新加载选项\n          if (confirm('连接失败，是否要重新加载页面尝试恢复连接？')) {\n            window.location.reload();\n          }\n        }\n      };\n      \n      // 连接错误\n      newSocket.onerror = (err) => {\n        console.error('WebSocket连接错误:', err);\n        error('连接发生错误，正在尝试重连...');\n      };\n      \n      // 收到消息\n      newSocket.onmessage = (event) => {\n        try {\n          // 检查是否为二进制数据（音频）\n          if (event.data instanceof Blob) {\n            console.log('收到二进制数据:', event.data.size, event.data.type);\n            handleBinaryMessage(event.data);\n            return;\n          }\n          \n          // 尝试解析JSON消息\n          const data = JSON.parse(event.data);\n          console.log('收到JSON消息:', data);\n          \n          // 处理ping响应\n          if (data.type === 'pong' && lastPingSentRef.current) {\n            const latency = Date.now() - data.original_timestamp;\n            console.log(`网络延迟: ${latency}ms`);\n            \n            setConnectionStats(prev => {\n              // 计算移动平均延迟\n              const newAvgLatency = prev.avgLatency ? \n                (prev.avgLatency * 0.8 + latency * 0.2) : latency;\n                \n              return {\n                ...prev,\n                pingTime: latency,\n                avgLatency: newAvgLatency,\n                lastPingAt: Date.now()\n              };\n            });\n          }\n          \n          // 更新最近消息状态\n          setLastMessage(data);\n          \n          // 根据消息类型处理\n          switch (data.type) {\n            case 'thinking':\n              setLoading(true, data.message || '思考中...');\n              break;\n              \n            case 'bot_reply':\n              // 添加消息到历史\n              addMessage({\n                role: 'assistant',\n                content: data.text || data.message,\n                timestamp: new Date().toISOString()\n              });\n              setLoading(false);\n              break;\n              \n            case 'transcription':\n              // 处理语音转写结果\n              if (data.final) {\n                addMessage({\n                  role: 'user',\n                  content: data.text,\n                  timestamp: new Date().toISOString()\n                });\n              }\n              break;\n              \n            case 'generating_video':\n              setLoading(true, data.message || '生成视频中...');\n              break;\n              \n            case 'video_ready':\n              setLoading(false);\n              if (data.success && data.video_url) {\n                console.log('视频已就绪:', data.video_url);\n                \n                // 添加视频消息\n                addMessage({\n                  role: 'assistant',\n                  content: data.message || '视频已准备就绪',\n                  video_url: data.video_url,\n                  timestamp: new Date().toISOString()\n                });\n              }\n              break;\n              \n            case 'webrtc_support':\n              // 更新WebRTC支持状态\n              setWebrtcSupported(data.supported);\n              console.log('服务器WebRTC支持状态:', data.supported);\n              if (data.supported) {\n                success('语音转写功能已就绪');\n              } else {\n                console.warn('服务器不支持WebRTC或Deepgram集成，将使用备用方法');\n              }\n              break;\n              \n            case 'error':\n              setLoading(false);\n              error(data.message || '发生错误');\n              \n              // 添加错误消息\n              addMessage({\n                role: 'system',\n                content: data.message || '发生错误',\n                error: true,\n                timestamp: new Date().toISOString()\n              });\n              break;\n              \n            default:\n              break;\n          }\n        } catch (err) {\n          console.error('处理WebSocket消息错误:', err);\n        }\n      };\n      \n      setSocket(newSocket);\n    };\n    \n    connect();\n    \n    // 组件卸载时清理WebSocket连接和定时器\n    return () => {\n      clearInterval(pingIntervalRef.current);\n      if (socketRef.current) {\n        socketRef.current.close();\n      }\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [config, success, error]);\n\n  // 组件挂载时初始化WebSocket\n  useEffect(() => {\n    initWebSocket();\n    \n    // 清理函数\n    return () => {\n      if (socket) {\n        socket.close();\n      }\n    };\n  }, [initWebSocket]);\n\n  // 更新状态\n  const updateStatus = (status, message) => {\n    setConnectionStatus(status);\n    setStatusMessage(message);\n  };\n\n  // 设置加载状态\n  const setLoading = (isLoading, message = '') => {\n    setIsLoading(isLoading);\n    setLoadingMessage(message);\n  };\n\n  // 添加消息到历史记录\n  const addMessage = (message) => {\n    setMessages(prevMessages => [...prevMessages, message]);\n    \n    // 触发消息事件，方便其他组件监听\n    const event = new CustomEvent('new-message', { detail: message });\n    window.dispatchEvent(event);\n  };\n\n  // 发送文本消息\n  const sendMessage = useCallback((message) => {\n    // 如果传入的是字符串，转换为标准消息格式\n    const messageToSend = typeof message === 'string' \n      ? { type: 'text_input', text: message }\n      : message;\n    \n    // 添加网络状态和时间戳\n    const enhancedMessage = {\n      ...messageToSend,\n      client_timestamp: Date.now(),\n      client_connection_stats: connectionStats\n    };\n    \n    // 检查websocket连接状态\n    if (!socket || socket.readyState !== WebSocket.OPEN) {\n      console.warn('WebSocket连接未建立，消息将被缓存');\n      \n      // 缓存消息，等待重连后发送\n      if (messageToSend.type !== 'ping') { // 不缓存ping消息\n        setPendingMessages(prev => [...prev, enhancedMessage]);\n        \n        // 只有在特定消息类型时才显示通知\n        if (['text_input', 'transcription', 'transcription_complete'].includes(messageToSend.type)) {\n          error('网络连接中断，消息将在重连后发送');\n        }\n      }\n      \n      return false;\n    }\n    \n    try {      \n      // 记录用户消息（对于文本输入类型）\n      if (messageToSend.type === 'text_input' && messageToSend.text) {\n        addMessage({\n          role: 'user',\n          content: messageToSend.text,\n          timestamp: new Date().toISOString(),\n          pending: pendingMessages.length > 0, // 标记是否有待发送消息\n        });\n        \n        // 设置处理状态\n        setIsProcessing(true);\n      }\n      \n      console.log('发送WebSocket消息:', enhancedMessage);\n      socket.send(JSON.stringify(enhancedMessage));\n      return true;\n    } catch (err) {\n      console.error(`发送消息失败: ${err.message}`);\n      \n      // 发送失败，缓存消息（除了ping）\n      if (messageToSend.type !== 'ping') {\n        setPendingMessages(prev => [...prev, enhancedMessage]);\n        error(`发送消息失败: ${err.message}，将在连接恢复后重试`);\n      }\n      \n      setIsProcessing(false);\n      return false;\n    }\n  }, [socket, error]);\n\n  // 处理二进制消息(用于音频播放)\n  const handleBinaryMessage = (binaryData) => {\n    // 处理接收到的二进制数据(通常是音频)\n    try {\n      // 创建音频URL\n      const audioUrl = URL.createObjectURL(binaryData);\n      \n      // 创建音频元素并播放\n      const audio = new Audio(audioUrl);\n      \n      // 播放完成后释放URL\n      audio.onended = () => {\n        URL.revokeObjectURL(audioUrl);\n      };\n      \n      audio.onerror = (err) => {\n        console.error('音频播放错误:', err);\n        URL.revokeObjectURL(audioUrl);\n      };\n      \n      // 播放音频\n      audio.play().catch(err => {\n        console.error('无法自动播放音频:', err);\n        error('请点击页面以启用音频播放');\n      });\n    } catch (err) {\n      console.error('处理二进制数据错误:', err);\n    }\n  };\n\n  // 提供上下文值\n  const contextValue = {\n    socket,\n    isConnected,\n    connectionStatus,\n    statusMessage,\n    isLoading,\n    loadingMessage,\n    lastMessage,\n    messages,\n    isProcessing,\n    webrtcSupported,\n    connectionStats,\n    pendingMessages,\n    sendMessage,\n    addMessage,\n    setLoading,\n    clearMessages: () => setMessages([]),\n    clearPendingMessages: () => setPendingMessages([]),\n    hasPendingMessages: pendingMessages.length > 0\n  };\n\n  return (\n    <WebSocketContext.Provider value={contextValue}>\n      {children}\n    </WebSocketContext.Provider>\n  );\n};\n\n// 自定义Hook，用于在组件中访问WebSocket功能\nexport const useWebSocket = () => {\n  const context = useContext(WebSocketContext);\n  if (!context) {\n    throw new Error('useWebSocket 必须在 WebSocketProvider 内部使用');\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}