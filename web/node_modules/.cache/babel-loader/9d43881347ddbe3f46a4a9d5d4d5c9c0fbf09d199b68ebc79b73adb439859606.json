{"ast":null,"code":"import { DEFAULT_AGENT_URL } from \"../lib/constants\";\nimport { AgentEvents } from \"../lib/enums/AgentEvents\";\nimport { DeepgramError } from \"../lib/errors\";\nimport { AbstractLiveClient } from \"./AbstractLiveClient\";\nexport class AgentLiveClient extends AbstractLiveClient {\n  constructor(options, endpoint = \"/agent\") {\n    var _a, _b, _c, _d;\n    super(options);\n    this.namespace = \"agent\";\n    this.baseUrl = (_d = (_c = (_b = (_a = options.agent) === null || _a === void 0 ? void 0 : _a.websocket) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.url) !== null && _d !== void 0 ? _d : DEFAULT_AGENT_URL;\n    this.connect({}, endpoint);\n  }\n  /**\n   * Sets up the connection event handlers.\n   * This method is responsible for handling the various events that can occur on the WebSocket connection, such as opening, closing, and receiving messages.\n   * - When the connection is opened, it emits the `AgentEvents.Open` event.\n   * - When the connection is closed, it emits the `AgentEvents.Close` event.\n   * - When an error occurs on the connection, it emits the `AgentEvents.Error` event.\n   * - When a message is received, it parses the message and emits the appropriate event based on the message type.\n   */\n  setupConnection() {\n    if (this.conn) {\n      this.conn.onopen = () => {\n        this.emit(AgentEvents.Open, this);\n      };\n      this.conn.onclose = event => {\n        this.emit(AgentEvents.Close, event);\n      };\n      this.conn.onerror = event => {\n        this.emit(AgentEvents.Error, event);\n      };\n      this.conn.onmessage = event => {\n        this.handleMessage(event);\n      };\n    }\n  }\n  /**\n   * Handles incoming messages from the WebSocket connection.\n   * @param event - The MessageEvent object representing the received message.\n   */\n  handleMessage(event) {\n    if (typeof event.data === \"string\") {\n      try {\n        const data = JSON.parse(event.data);\n        this.handleTextMessage(data);\n      } catch (error) {\n        this.emit(AgentEvents.Error, {\n          event,\n          message: \"Unable to parse `data` as JSON.\",\n          error\n        });\n      }\n    } else if (event.data instanceof Blob) {\n      event.data.arrayBuffer().then(buffer => {\n        this.handleBinaryMessage(Buffer.from(buffer));\n      });\n    } else if (event.data instanceof ArrayBuffer) {\n      this.handleBinaryMessage(Buffer.from(event.data));\n    } else if (Buffer.isBuffer(event.data)) {\n      this.handleBinaryMessage(event.data);\n    } else {\n      console.log(\"Received unknown data type\", event.data);\n      this.emit(AgentEvents.Error, {\n        event,\n        message: \"Received unknown data type.\"\n      });\n    }\n  }\n  /**\n   * Handles binary messages received from the WebSocket connection.\n   * @param data - The binary data.\n   */\n  handleBinaryMessage(data) {\n    this.emit(AgentEvents.Audio, data);\n  }\n  /**\n   * Handles text messages received from the WebSocket connection.\n   * @param data - The parsed JSON data.\n   */\n  handleTextMessage(data) {\n    if (data.type in AgentEvents) {\n      this.emit(data.type, data);\n    } else {\n      this.emit(AgentEvents.Unhandled, data);\n    }\n  }\n  /**\n   * To be called with your model configuration BEFORE sending\n   * any audio data.\n   * @param options - The SettingsConfiguration object.\n   * @param options.audio.input.encoding - The encoding for your inbound (user) audio.\n   * @param options.audio.input.sampleRate - The sample rate for your inbound (user) audio.\n   * @param options.audio.output.encoding - The encoding for your outbound (agent) audio.\n   * @param options.audio.output.sampleRate - The sample rate for your outbound (agent) audio.\n   * @param options.audio.output.bitrate - The bitrate for your outbound (agent) audio.\n   * @param options.audio.output.container - The container for your outbound (agent) audio.\n   * @param options.agent.listen.model - The STT model to use for processing user audio.\n   * @param options.agent.speak.model - The TTS model to use for generating agent audio.\n   * @param options.agent.think.provider.type - The LLM provider to use.\n   * @param options.agent.think.model - The LLM model to use.\n   * @param options.agent.think.instructions - The instructions to provide to the LLM.\n   * @param options.agent.think.functions - The functions to provide to the LLM.\n   * @param options.context.messages - The message history to provide to the LLM (useful if a websocket connection is lost.)\n   * @param options.context.replay - Whether to replay the last message if it was an assistant message.\n   */\n  configure(options) {\n    var _a, _b, _c;\n    // @ts-expect-error Not every consumer of the SDK is using TypeScript, this conditional exists to catch runtime errors for JS code where there is no compile-time checking.\n    if (!options.agent.listen.model.startsWith(\"nova-3\") && ((_a = options.agent.listen.keyterm) === null || _a === void 0 ? void 0 : _a.length)) {\n      throw new DeepgramError(\"Keyterms are only supported with the Nova 3 models.\");\n    }\n    // Converting the property names...\n    const opts = Object.assign({}, options);\n    opts.audio.input[\"sample_rate\"] = (_b = options.audio.input) === null || _b === void 0 ? void 0 : _b.sampleRate;\n    delete opts.audio.input.sampleRate;\n    opts.audio.output[\"sample_rate\"] = (_c = options.audio.output) === null || _c === void 0 ? void 0 : _c.sampleRate;\n    delete opts.audio.output.sampleRate;\n    this.send(JSON.stringify(Object.assign({\n      type: \"SettingsConfiguration\"\n    }, opts)));\n  }\n  /**\n   * Provide new instructions to the LLM.\n   * @param instructions - The instructions to provide.\n   */\n  updateInstructions(instructions) {\n    this.send(JSON.stringify({\n      type: \"UpdateInstructions\",\n      instructions\n    }));\n  }\n  /**\n   * Change the speak model.\n   * @param model - The new model to use.\n   */\n  updateSpeak(model) {\n    this.send(JSON.stringify({\n      type: \"UpdateSpeak\",\n      model\n    }));\n  }\n  /**\n   * Immediately trigger an agent message. If this message\n   * is sent while the user is speaking, or while the server is in the\n   * middle of sending audio, then the request will be ignored and an InjectionRefused\n   * event will be emitted.\n   * @example \"Hold on while I look that up for you.\"\n   * @example \"Are you still on the line?\"\n   * @param message - The message to speak.\n   */\n  injectAgentMessage(message) {\n    this.send(JSON.stringify({\n      type: \"InjectAgentMessage\",\n      message\n    }));\n  }\n  /**\n   * Respond to a function call request.\n   * @param response  - The response to the function call request.\n   * @param response.function_call_id - The ID that was received in the request (these MUST match).\n   * @param response.output - The result of the function call.\n   */\n  functionCallResponse(response) {\n    this.send(JSON.stringify(Object.assign({\n      type: \"FunctionCallResponse\"\n    }, response)));\n  }\n  /**\n   * Send a keepalive to avoid closing the websocket while you\n   * are not transmitting audio. This should be sent at least\n   * every 8 seconds.\n   */\n  keepAlive() {\n    this.send(JSON.stringify({\n      type: \"KeepAlive\"\n    }));\n  }\n}","map":{"version":3,"names":["DEFAULT_AGENT_URL","AgentEvents","DeepgramError","AbstractLiveClient","AgentLiveClient","constructor","options","endpoint","namespace","baseUrl","_d","_c","_b","_a","agent","websocket","url","connect","setupConnection","conn","onopen","emit","Open","onclose","event","Close","onerror","Error","onmessage","handleMessage","data","JSON","parse","handleTextMessage","error","message","Blob","arrayBuffer","then","buffer","handleBinaryMessage","Buffer","from","ArrayBuffer","isBuffer","console","log","Audio","type","Unhandled","configure","listen","model","startsWith","keyterm","length","opts","Object","assign","audio","input","sampleRate","output","send","stringify","updateInstructions","instructions","updateSpeak","injectAgentMessage","functionCallResponse","response","keepAlive"],"sources":["/Users/niko/node_modules/.pnpm/@deepgram+sdk@3.11.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@deepgram/sdk/src/packages/AgentLiveClient.ts"],"sourcesContent":["import { DEFAULT_AGENT_URL } from \"../lib/constants\";\nimport { AgentEvents } from \"../lib/enums/AgentEvents\";\nimport { DeepgramError } from \"../lib/errors\";\nimport type {\n  AgentLiveSchema,\n  SpeakModel,\n  DeepgramClientOptions,\n  FunctionCallResponse,\n} from \"../lib/types\";\nimport { AbstractLiveClient } from \"./AbstractLiveClient\";\n\nexport class AgentLiveClient extends AbstractLiveClient {\n  public namespace: string = \"agent\";\n\n  constructor(options: DeepgramClientOptions, endpoint: string = \"/agent\") {\n    super(options);\n    this.baseUrl = options.agent?.websocket?.options?.url ?? DEFAULT_AGENT_URL;\n\n    this.connect({}, endpoint);\n  }\n\n  /**\n   * Sets up the connection event handlers.\n   * This method is responsible for handling the various events that can occur on the WebSocket connection, such as opening, closing, and receiving messages.\n   * - When the connection is opened, it emits the `AgentEvents.Open` event.\n   * - When the connection is closed, it emits the `AgentEvents.Close` event.\n   * - When an error occurs on the connection, it emits the `AgentEvents.Error` event.\n   * - When a message is received, it parses the message and emits the appropriate event based on the message type.\n   */\n  public setupConnection(): void {\n    if (this.conn) {\n      this.conn.onopen = () => {\n        this.emit(AgentEvents.Open, this);\n      };\n\n      this.conn.onclose = (event: any) => {\n        this.emit(AgentEvents.Close, event);\n      };\n\n      this.conn.onerror = (event: ErrorEvent) => {\n        this.emit(AgentEvents.Error, event);\n      };\n\n      this.conn.onmessage = (event: MessageEvent) => {\n        this.handleMessage(event);\n      };\n    }\n  }\n\n  /**\n   * Handles incoming messages from the WebSocket connection.\n   * @param event - The MessageEvent object representing the received message.\n   */\n  protected handleMessage(event: MessageEvent): void {\n    if (typeof event.data === \"string\") {\n      try {\n        const data = JSON.parse(event.data);\n        this.handleTextMessage(data);\n      } catch (error) {\n        this.emit(AgentEvents.Error, {\n          event,\n          message: \"Unable to parse `data` as JSON.\",\n          error,\n        });\n      }\n    } else if (event.data instanceof Blob) {\n      event.data.arrayBuffer().then((buffer) => {\n        this.handleBinaryMessage(Buffer.from(buffer));\n      });\n    } else if (event.data instanceof ArrayBuffer) {\n      this.handleBinaryMessage(Buffer.from(event.data));\n    } else if (Buffer.isBuffer(event.data)) {\n      this.handleBinaryMessage(event.data);\n    } else {\n      console.log(\"Received unknown data type\", event.data);\n      this.emit(AgentEvents.Error, {\n        event,\n        message: \"Received unknown data type.\",\n      });\n    }\n  }\n\n  /**\n   * Handles binary messages received from the WebSocket connection.\n   * @param data - The binary data.\n   */\n  protected handleBinaryMessage(data: Buffer): void {\n    this.emit(AgentEvents.Audio, data);\n  }\n\n  /**\n   * Handles text messages received from the WebSocket connection.\n   * @param data - The parsed JSON data.\n   */\n  protected handleTextMessage(data: any): void {\n    if (data.type in AgentEvents) {\n      this.emit(data.type, data);\n    } else {\n      this.emit(AgentEvents.Unhandled, data);\n    }\n  }\n\n  /**\n   * To be called with your model configuration BEFORE sending\n   * any audio data.\n   * @param options - The SettingsConfiguration object.\n   * @param options.audio.input.encoding - The encoding for your inbound (user) audio.\n   * @param options.audio.input.sampleRate - The sample rate for your inbound (user) audio.\n   * @param options.audio.output.encoding - The encoding for your outbound (agent) audio.\n   * @param options.audio.output.sampleRate - The sample rate for your outbound (agent) audio.\n   * @param options.audio.output.bitrate - The bitrate for your outbound (agent) audio.\n   * @param options.audio.output.container - The container for your outbound (agent) audio.\n   * @param options.agent.listen.model - The STT model to use for processing user audio.\n   * @param options.agent.speak.model - The TTS model to use for generating agent audio.\n   * @param options.agent.think.provider.type - The LLM provider to use.\n   * @param options.agent.think.model - The LLM model to use.\n   * @param options.agent.think.instructions - The instructions to provide to the LLM.\n   * @param options.agent.think.functions - The functions to provide to the LLM.\n   * @param options.context.messages - The message history to provide to the LLM (useful if a websocket connection is lost.)\n   * @param options.context.replay - Whether to replay the last message if it was an assistant message.\n   */\n  public configure(options: AgentLiveSchema): void {\n    // @ts-expect-error Not every consumer of the SDK is using TypeScript, this conditional exists to catch runtime errors for JS code where there is no compile-time checking.\n    if (!options.agent.listen.model.startsWith(\"nova-3\") && options.agent.listen.keyterm?.length) {\n      throw new DeepgramError(\"Keyterms are only supported with the Nova 3 models.\");\n    }\n    // Converting the property names...\n    const opts: Record<string, any> = { ...options };\n    opts.audio.input[\"sample_rate\"] = options.audio.input?.sampleRate;\n    delete opts.audio.input.sampleRate;\n    opts.audio.output[\"sample_rate\"] = options.audio.output?.sampleRate;\n    delete opts.audio.output.sampleRate;\n    this.send(JSON.stringify({ type: \"SettingsConfiguration\", ...opts }));\n  }\n\n  /**\n   * Provide new instructions to the LLM.\n   * @param instructions - The instructions to provide.\n   */\n  public updateInstructions(instructions: string): void {\n    this.send(JSON.stringify({ type: \"UpdateInstructions\", instructions }));\n  }\n\n  /**\n   * Change the speak model.\n   * @param model - The new model to use.\n   */\n  public updateSpeak(model: SpeakModel): void {\n    this.send(JSON.stringify({ type: \"UpdateSpeak\", model }));\n  }\n\n  /**\n   * Immediately trigger an agent message. If this message\n   * is sent while the user is speaking, or while the server is in the\n   * middle of sending audio, then the request will be ignored and an InjectionRefused\n   * event will be emitted.\n   * @example \"Hold on while I look that up for you.\"\n   * @example \"Are you still on the line?\"\n   * @param message - The message to speak.\n   */\n  public injectAgentMessage(message: string): void {\n    this.send(JSON.stringify({ type: \"InjectAgentMessage\", message }));\n  }\n\n  /**\n   * Respond to a function call request.\n   * @param response  - The response to the function call request.\n   * @param response.function_call_id - The ID that was received in the request (these MUST match).\n   * @param response.output - The result of the function call.\n   */\n  public functionCallResponse(response: FunctionCallResponse): void {\n    this.send(JSON.stringify({ type: \"FunctionCallResponse\", ...response }));\n  }\n\n  /**\n   * Send a keepalive to avoid closing the websocket while you\n   * are not transmitting audio. This should be sent at least\n   * every 8 seconds.\n   */\n  public keepAlive(): void {\n    this.send(JSON.stringify({ type: \"KeepAlive\" }));\n  }\n}\n"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,kBAAkB;AACpD,SAASC,WAAW,QAAQ,0BAA0B;AACtD,SAASC,aAAa,QAAQ,eAAe;AAO7C,SAASC,kBAAkB,QAAQ,sBAAsB;AAEzD,OAAM,MAAOC,eAAgB,SAAQD,kBAAkB;EAGrDE,YAAYC,OAA8B,EAAEC,QAAA,GAAmB,QAAQ;;IACrE,KAAK,CAACD,OAAO,CAAC;IAHT,KAAAE,SAAS,GAAW,OAAO;IAIhC,IAAI,CAACC,OAAO,GAAG,CAAAC,EAAA,IAAAC,EAAA,IAAAC,EAAA,IAAAC,EAAA,GAAAP,OAAO,CAACQ,KAAK,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,SAAS,cAAAH,EAAA,uBAAAA,EAAA,CAAEN,OAAO,cAAAK,EAAA,uBAAAA,EAAA,CAAEK,GAAG,cAAAN,EAAA,cAAAA,EAAA,GAAIV,iBAAiB;IAE1E,IAAI,CAACiB,OAAO,CAAC,EAAE,EAAEV,QAAQ,CAAC;EAC5B;EAEA;;;;;;;;EAQOW,eAAeA,CAAA;IACpB,IAAI,IAAI,CAACC,IAAI,EAAE;MACb,IAAI,CAACA,IAAI,CAACC,MAAM,GAAG,MAAK;QACtB,IAAI,CAACC,IAAI,CAACpB,WAAW,CAACqB,IAAI,EAAE,IAAI,CAAC;MACnC,CAAC;MAED,IAAI,CAACH,IAAI,CAACI,OAAO,GAAIC,KAAU,IAAI;QACjC,IAAI,CAACH,IAAI,CAACpB,WAAW,CAACwB,KAAK,EAAED,KAAK,CAAC;MACrC,CAAC;MAED,IAAI,CAACL,IAAI,CAACO,OAAO,GAAIF,KAAiB,IAAI;QACxC,IAAI,CAACH,IAAI,CAACpB,WAAW,CAAC0B,KAAK,EAAEH,KAAK,CAAC;MACrC,CAAC;MAED,IAAI,CAACL,IAAI,CAACS,SAAS,GAAIJ,KAAmB,IAAI;QAC5C,IAAI,CAACK,aAAa,CAACL,KAAK,CAAC;MAC3B,CAAC;;EAEL;EAEA;;;;EAIUK,aAAaA,CAACL,KAAmB;IACzC,IAAI,OAAOA,KAAK,CAACM,IAAI,KAAK,QAAQ,EAAE;MAClC,IAAI;QACF,MAAMA,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACR,KAAK,CAACM,IAAI,CAAC;QACnC,IAAI,CAACG,iBAAiB,CAACH,IAAI,CAAC;OAC7B,CAAC,OAAOI,KAAK,EAAE;QACd,IAAI,CAACb,IAAI,CAACpB,WAAW,CAAC0B,KAAK,EAAE;UAC3BH,KAAK;UACLW,OAAO,EAAE,iCAAiC;UAC1CD;SACD,CAAC;;KAEL,MAAM,IAAIV,KAAK,CAACM,IAAI,YAAYM,IAAI,EAAE;MACrCZ,KAAK,CAACM,IAAI,CAACO,WAAW,EAAE,CAACC,IAAI,CAAEC,MAAM,IAAI;QACvC,IAAI,CAACC,mBAAmB,CAACC,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC,CAAC;MAC/C,CAAC,CAAC;KACH,MAAM,IAAIf,KAAK,CAACM,IAAI,YAAYa,WAAW,EAAE;MAC5C,IAAI,CAACH,mBAAmB,CAACC,MAAM,CAACC,IAAI,CAAClB,KAAK,CAACM,IAAI,CAAC,CAAC;KAClD,MAAM,IAAIW,MAAM,CAACG,QAAQ,CAACpB,KAAK,CAACM,IAAI,CAAC,EAAE;MACtC,IAAI,CAACU,mBAAmB,CAAChB,KAAK,CAACM,IAAI,CAAC;KACrC,MAAM;MACLe,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAEtB,KAAK,CAACM,IAAI,CAAC;MACrD,IAAI,CAACT,IAAI,CAACpB,WAAW,CAAC0B,KAAK,EAAE;QAC3BH,KAAK;QACLW,OAAO,EAAE;OACV,CAAC;;EAEN;EAEA;;;;EAIUK,mBAAmBA,CAACV,IAAY;IACxC,IAAI,CAACT,IAAI,CAACpB,WAAW,CAAC8C,KAAK,EAAEjB,IAAI,CAAC;EACpC;EAEA;;;;EAIUG,iBAAiBA,CAACH,IAAS;IACnC,IAAIA,IAAI,CAACkB,IAAI,IAAI/C,WAAW,EAAE;MAC5B,IAAI,CAACoB,IAAI,CAACS,IAAI,CAACkB,IAAI,EAAElB,IAAI,CAAC;KAC3B,MAAM;MACL,IAAI,CAACT,IAAI,CAACpB,WAAW,CAACgD,SAAS,EAAEnB,IAAI,CAAC;;EAE1C;EAEA;;;;;;;;;;;;;;;;;;;EAmBOoB,SAASA,CAAC5C,OAAwB;;IACvC;IACA,IAAI,CAACA,OAAO,CAACQ,KAAK,CAACqC,MAAM,CAACC,KAAK,CAACC,UAAU,CAAC,QAAQ,CAAC,KAAI,CAAAxC,EAAA,GAAAP,OAAO,CAACQ,KAAK,CAACqC,MAAM,CAACG,OAAO,cAAAzC,EAAA,uBAAAA,EAAA,CAAE0C,MAAM,GAAE;MAC5F,MAAM,IAAIrD,aAAa,CAAC,qDAAqD,CAAC;;IAEhF;IACA,MAAMsD,IAAI,GAAAC,MAAA,CAAAC,MAAA,KAA6BpD,OAAO,CAAE;IAChDkD,IAAI,CAACG,KAAK,CAACC,KAAK,CAAC,aAAa,CAAC,GAAG,CAAAhD,EAAA,GAAAN,OAAO,CAACqD,KAAK,CAACC,KAAK,cAAAhD,EAAA,uBAAAA,EAAA,CAAEiD,UAAU;IACjE,OAAOL,IAAI,CAACG,KAAK,CAACC,KAAK,CAACC,UAAU;IAClCL,IAAI,CAACG,KAAK,CAACG,MAAM,CAAC,aAAa,CAAC,GAAG,CAAAnD,EAAA,GAAAL,OAAO,CAACqD,KAAK,CAACG,MAAM,cAAAnD,EAAA,uBAAAA,EAAA,CAAEkD,UAAU;IACnE,OAAOL,IAAI,CAACG,KAAK,CAACG,MAAM,CAACD,UAAU;IACnC,IAAI,CAACE,IAAI,CAAChC,IAAI,CAACiC,SAAS,CAAAP,MAAA,CAAAC,MAAA;MAAGV,IAAI,EAAE;IAAuB,GAAKQ,IAAI,EAAG,CAAC;EACvE;EAEA;;;;EAIOS,kBAAkBA,CAACC,YAAoB;IAC5C,IAAI,CAACH,IAAI,CAAChC,IAAI,CAACiC,SAAS,CAAC;MAAEhB,IAAI,EAAE,oBAAoB;MAAEkB;IAAY,CAAE,CAAC,CAAC;EACzE;EAEA;;;;EAIOC,WAAWA,CAACf,KAAiB;IAClC,IAAI,CAACW,IAAI,CAAChC,IAAI,CAACiC,SAAS,CAAC;MAAEhB,IAAI,EAAE,aAAa;MAAEI;IAAK,CAAE,CAAC,CAAC;EAC3D;EAEA;;;;;;;;;EASOgB,kBAAkBA,CAACjC,OAAe;IACvC,IAAI,CAAC4B,IAAI,CAAChC,IAAI,CAACiC,SAAS,CAAC;MAAEhB,IAAI,EAAE,oBAAoB;MAAEb;IAAO,CAAE,CAAC,CAAC;EACpE;EAEA;;;;;;EAMOkC,oBAAoBA,CAACC,QAA8B;IACxD,IAAI,CAACP,IAAI,CAAChC,IAAI,CAACiC,SAAS,CAAAP,MAAA,CAAAC,MAAA;MAAGV,IAAI,EAAE;IAAsB,GAAKsB,QAAQ,EAAG,CAAC;EAC1E;EAEA;;;;;EAKOC,SAASA,CAAA;IACd,IAAI,CAACR,IAAI,CAAChC,IAAI,CAACiC,SAAS,CAAC;MAAEhB,IAAI,EAAE;IAAW,CAAE,CAAC,CAAC;EAClD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}