{"ast":null,"code":"var _jsxFileName = \"/Users/niko/digital-human/frontend/src/components/RecordButton/index.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useWebSocket } from '../../contexts/WebSocketContext';\nimport { useNotification } from '../../contexts/NotificationContext';\nimport './RecordButton.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst RecordButton = () => {\n  _s();\n  const {\n    sendAudio,\n    isProcessing\n  } = useWebSocket();\n  const {\n    error,\n    info\n  } = useNotification();\n  const [isRecording, setIsRecording] = useState(false);\n  const [recorder, setRecorder] = useState(null);\n  const [stream, setStream] = useState(null);\n  useEffect(() => {\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (recorder) {\n        recorder.ondataavailable = null;\n        recorder.onstop = null;\n      }\n    };\n  }, [recorder, stream]);\n  const startRecording = async () => {\n    try {\n      const audioStream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      setStream(audioStream);\n\n      // 设置MediaRecorder配置\n      const options = {\n        mimeType: 'audio/webm',\n        audioBitsPerSecond: 128000\n      };\n\n      // 尝试使用支持的音频格式\n      let mediaRecorder;\n      try {\n        mediaRecorder = new MediaRecorder(audioStream, options);\n        console.log(\"使用 audio/webm 格式录音\");\n      } catch (e) {\n        console.warn(\"audio/webm 不支持，尝试默认格式\");\n        mediaRecorder = new MediaRecorder(audioStream);\n        console.log(`使用默认格式录音: ${mediaRecorder.mimeType || '未知'}`);\n      }\n      setRecorder(mediaRecorder);\n      const audioChunks = [];\n      mediaRecorder.ondataavailable = e => {\n        if (e.data.size > 0) {\n          audioChunks.push(e.data);\n          console.log(`收集音频数据块: ${e.data.size} 字节, 类型: ${e.data.type}`);\n        }\n      };\n      mediaRecorder.onstop = () => {\n        if (audioChunks.length === 0) {\n          console.warn(\"没有收集到音频数据\");\n          setIsRecording(false);\n          return;\n        }\n        const audioBlob = new Blob(audioChunks, {\n          type: mediaRecorder.mimeType || 'audio/webm'\n        });\n        console.log(`录音完成，总大小: ${audioBlob.size} 字节, 类型: ${audioBlob.type}`);\n\n        // 在这里检查audioBlob是否有效\n        if (audioBlob.size > 0) {\n          console.log(\"发送音频数据到WebSocket\");\n          sendAudio(audioBlob);\n        } else {\n          console.error(\"音频Blob为空，取消发送\");\n          error(\"录音失败：未捕获到有效音频\");\n        }\n        setIsRecording(false);\n      };\n\n      // 设置较小的时间片段，以便及时传输音频数据\n      mediaRecorder.start(1000); // 每秒发送一次数据\n      setIsRecording(true);\n      console.log('录音已开始，音频数据将每秒发送一次');\n    } catch (err) {\n      console.error('无法访问麦克风:', err);\n      error(`无法访问麦克风: ${err.message}`);\n      setIsRecording(false);\n    }\n  };\n  const stopRecording = () => {\n    if (recorder && recorder.state !== 'inactive') {\n      recorder.stop();\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n        setStream(null);\n      }\n    }\n  };\n  const handleRecordClick = () => {\n    if (isRecording) {\n      stopRecording();\n    } else {\n      startRecording();\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"button\", {\n    className: `record-button ${isRecording ? 'recording' : ''} ${isProcessing ? 'disabled' : ''}`,\n    onClick: handleRecordClick,\n    disabled: isProcessing,\n    children: isRecording ? '停止录音' : '开始录音'\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 111,\n    columnNumber: 5\n  }, this);\n};\n_s(RecordButton, \"qg8cQZuUq4cQnGUK80ZLPqvG0cI=\", false, function () {\n  return [useWebSocket, useNotification];\n});\n_c = RecordButton;\nexport default RecordButton;\nvar _c;\n$RefreshReg$(_c, \"RecordButton\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useWebSocket","useNotification","jsxDEV","_jsxDEV","RecordButton","_s","sendAudio","isProcessing","error","info","isRecording","setIsRecording","recorder","setRecorder","stream","setStream","getTracks","forEach","track","stop","ondataavailable","onstop","startRecording","audioStream","navigator","mediaDevices","getUserMedia","audio","options","mimeType","audioBitsPerSecond","mediaRecorder","MediaRecorder","console","log","e","warn","audioChunks","data","size","push","type","length","audioBlob","Blob","start","err","message","stopRecording","state","handleRecordClick","className","onClick","disabled","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/niko/digital-human/frontend/src/components/RecordButton/index.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { useWebSocket } from '../../contexts/WebSocketContext';\nimport { useNotification } from '../../contexts/NotificationContext';\nimport './RecordButton.css';\n\nconst RecordButton = () => {\n  const { sendAudio, isProcessing } = useWebSocket();\n  const { error, info } = useNotification();\n  const [isRecording, setIsRecording] = useState(false);\n  const [recorder, setRecorder] = useState(null);\n  const [stream, setStream] = useState(null);\n  \n  useEffect(() => {\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (recorder) {\n        recorder.ondataavailable = null;\n        recorder.onstop = null;\n      }\n    };\n  }, [recorder, stream]);\n  \n  const startRecording = async () => {\n    try {\n      const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      setStream(audioStream);\n      \n      // 设置MediaRecorder配置\n      const options = { \n        mimeType: 'audio/webm',\n        audioBitsPerSecond: 128000 \n      };\n      \n      // 尝试使用支持的音频格式\n      let mediaRecorder;\n      try {\n        mediaRecorder = new MediaRecorder(audioStream, options);\n        console.log(\"使用 audio/webm 格式录音\");\n      } catch (e) {\n        console.warn(\"audio/webm 不支持，尝试默认格式\");\n        mediaRecorder = new MediaRecorder(audioStream);\n        console.log(`使用默认格式录音: ${mediaRecorder.mimeType || '未知'}`);\n      }\n      \n      setRecorder(mediaRecorder);\n      \n      const audioChunks = [];\n      \n      mediaRecorder.ondataavailable = (e) => {\n        if (e.data.size > 0) {\n          audioChunks.push(e.data);\n          console.log(`收集音频数据块: ${e.data.size} 字节, 类型: ${e.data.type}`);\n        }\n      };\n      \n      mediaRecorder.onstop = () => {\n        if (audioChunks.length === 0) {\n          console.warn(\"没有收集到音频数据\");\n          setIsRecording(false);\n          return;\n        }\n        \n        const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });\n        console.log(`录音完成，总大小: ${audioBlob.size} 字节, 类型: ${audioBlob.type}`);\n        \n        // 在这里检查audioBlob是否有效\n        if (audioBlob.size > 0) {\n          console.log(\"发送音频数据到WebSocket\");\n          sendAudio(audioBlob);\n        } else {\n          console.error(\"音频Blob为空，取消发送\");\n          error(\"录音失败：未捕获到有效音频\");\n        }\n        \n        setIsRecording(false);\n      };\n      \n      // 设置较小的时间片段，以便及时传输音频数据\n      mediaRecorder.start(1000); // 每秒发送一次数据\n      setIsRecording(true);\n      console.log('录音已开始，音频数据将每秒发送一次');\n    } catch (err) {\n      console.error('无法访问麦克风:', err);\n      error(`无法访问麦克风: ${err.message}`);\n      setIsRecording(false);\n    }\n  };\n  \n  const stopRecording = () => {\n    if (recorder && recorder.state !== 'inactive') {\n      recorder.stop();\n      \n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n        setStream(null);\n      }\n    }\n  };\n  \n  const handleRecordClick = () => {\n    if (isRecording) {\n      stopRecording();\n    } else {\n      startRecording();\n    }\n  };\n  \n  return (\n    <button \n      className={`record-button ${isRecording ? 'recording' : ''} ${isProcessing ? 'disabled' : ''}`}\n      onClick={handleRecordClick}\n      disabled={isProcessing}\n    >\n      {isRecording ? '停止录音' : '开始录音'}\n    </button>\n  );\n};\n\nexport default RecordButton;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}